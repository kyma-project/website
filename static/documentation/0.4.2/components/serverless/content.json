{
  "id": "serverless",
  "displayName": "Serverless",
  "description": "Overal documentation for Serverless",
  "type": "Components",
  "docs": [
    {
      "order": "001-overview-serverless",
      "title": "Overview",
      "source": "<p>Lambdas or lambda functions are small functions that run in Kyma in a cost-efficient and scalable way using JavaScript in Node.js. As the following diagram shows, these functions enable the linking of a wide range of functionalities using Kyma.</p>\n<p><img src=\"assets/kyma_connected.png\" alt=\"Kyma connected to other products through Lambda functions\"></p>\n<p>This is an example lambda function:</p>\n<pre><code>def myfunction (event, context):\n  print event\n  return event[&#39;data&#39;]\n</code></pre><p>The use of lambdas in Kyma addresses several scenarios:  </p>\n<ul>\n<li>Create and manage lambda functions</li>\n<li>Trigger functions based on business Events</li>\n<li>Expose functions through HTTP</li>\n<li>Consume services</li>\n<li>Provide customers with customized features</li>\n<li>Version lambda functions</li>\n<li>Chain multiple functions</li>\n</ul>\n<p>Lambda functions best serve integration purposes due to their ease of use. Lambda is a quick and ideal solution when the goal is to combine functionalities which are tightly coupled. And, in the context of Kyma, they provide integration with the Event system and Customer Engagement and Commerce tools. Lambda functions are not well-suited to building an application from scratch.</p>\n<p>The Serverless implementation of Kyma is based on <a href=\"https://github.com/kubeless/kubeless\" target=\"_blank\">Kubeless</a>.</p>\n"
    },
    {
      "order": "020-details-custom-resources",
      "title": "Custom Resources",
      "type": "Details",
      "source": "<p>Kubeless uses custom resource definitions (CRD) to:</p>\n<ul>\n<li>define the information required for the configuration of custom resources</li>\n<li>create functions</li>\n<li>create objects</li>\n</ul>\n<p>The function CRD ships by default with Kubeless.</p>\n<p>See the content of the <code>kubeless-crd.yaml</code> file: </p>\n<pre><code>apiVersion: apiextensions.k8s.io/v1beta1\ndescription: Kubernetes Native Serverless Framework\nkind: CustomResourceDefinition\nmetadata:\n  name: {{ .Values.function.customResourceDefinition.metadata.name | quote }}\n  labels:\n{{ include &quot;labels.standard&quot; . | indent 4 }}\nspec:\n  group: {{ .Values.function.customResourceDefinition.spec.group | quote }}\n  names:\n    kind: {{ .Values.function.customResourceDefinition.names.kind | quote }}\n    plural: {{ .Values.function.customResourceDefinition.names.plural | quote }}\n    singular: {{ .Values.function.customResourceDefinition.names.singular | quote }}\n  scope: Namespaced\n  version: v1beta1\n</code></pre><p>Use the <code>.yaml</code> file to create the custom resource using the following command:</p>\n<pre><code>kubectl create -f &lt;filename&gt;\n</code></pre><p>Kubeless creates a new namespaced endpoint that you can use to create and manage custom objects. Learn how to use CRDs to create objects in the Kubeless documentation on the <a href=\"https://kubeless.io/\" target=\"_blank\">Kubeless website</a>.</p>\n"
    },
    {
      "order": "021-details-managing-lambdas",
      "title": "Managing Lambdas",
      "type": "Details",
      "source": "<p>Kubernetes provides Kyma with labels that allow you to arrange lambda functions and group them. Labeling also makes it possible to filter lambdas functions. This functionality is particularly useful when a developer needs to manage a large set of lambda functions.</p>\n<p>Behind the scenes, labeling takes place in the form of key value pairs. Here is an example of code that enhances a function:</p>\n<pre><code>&quot;labels&quot;: {\n  &quot;key1&quot; : &quot;value1&quot;,\n  &quot;key2&quot; : &quot;value2&quot;\n}\n</code></pre><p>For more details on labels and selectors, visit the <a href=\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\" target=\"_blank\">Kubernetes website</a>.</p>\n"
    },
    {
      "order": "022-details-programming-model",
      "title": "The Node.js Programming Model",
      "type": "Details",
      "source": "<p>Kyma supports Node.js 6 and 8. The function interface is the same for both versions. It is still best practice to start with Node.js 8, as it supports Promises out of the box. The result is less complicated code.</p>\n<p>Please set the runtime version (Node.js 6 or 8) while creating a function.</p>\n<p>In the next sections, we will describe how the system creates Node.js functions.</p>\n<h3 id=\"the-handler\">The Handler</h3>\n<p>The system uses <code>module.exports</code> to export Node.js handlers. A handler represents the function code executed during invocation. You have to define the handler using the command line. The Console UI only supports <code>main</code> as a handler name.</p>\n<pre><code class=\"lang-JavaScript\">module.exports = { main: function (event, context) {\n    return\n} }\n</code></pre>\n<p>Kyma  supports two execution types: <strong>Request / Response (HTTP)</strong> and <strong>Events</strong>. In both types, a <code>return</code> identifies a successful execution of the function. For event types, the event is reinjected as long as the execution is not successful. Functions of the Request Response type can return data to the requesting entity. The following three options are available:</p>\n<table>\n<thead>\n<tr>\n<th>Return</th>\n<th>Content Type</th>\n<th>HTTP Status</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>return</code></td>\n<td>none</td>\n<td>200 (OK)</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>return &quot;Hello World!&quot;</code></td>\n<td>none</td>\n<td>200 (OK)</td>\n<td>Hello World!</td>\n</tr>\n<tr>\n<td><code>return {foo: &quot;BAR&quot;}</code></td>\n<td>application/json</td>\n<td>200 (OK)</td>\n<td>{&quot;foo&quot;:&quot;BAR&quot;}</td>\n</tr>\n</tbody>\n</table>\n<p>A failing function simply throws an error to tell the event service to reinject the event at a later point. An HTTP-based function returns an HTTP 500 status.</p>\n<h3 id=\"the-event-object-and-context-object\">The Event Object and Context Object</h3>\n<p>The function retrieves two parameters: Event and Context.</p>\n<pre><code class=\"lang-yaml\">event:\n  data:                                         # Event data\n    foo: &quot;bar&quot;                                  # The data is parsed as JSON when required\n  extensions:                                   # Optional parameters\n    request: ...                                # Reference to the request received\n    response: ...                               # Reference to the response to send\n                                                # (specific properties will depend on the function language)\ncontext:\n    function-name: &quot;pubsub-nodejs&quot;\n    timeout: &quot;180&quot;\n    runtime: &quot;nodejs6&quot;\n    memory-limit: &quot;128M&quot;\n</code></pre>\n<p>The Event contains the event payload as well as some request specific metadata. The request and response attributes are primarily responsible for providing control over http behavior.</p>\n<h3 id=\"advanced-response-handling\">Advanced Response Handling</h3>\n<p>To enable more advanced implementations, the system forwards Node.js Request and Response objects to the function. Access the objects using <code>event.extensions.&lt;request|response&gt;</code>.</p>\n<p>In the example, a custom HTTP response is set.</p>\n<pre><code class=\"lang-JavaScript\">module.exports = { main: function (event, context) {\n    console.log(event.extensions.request.originalUrl)\n    event.extensions.response.status(404).send(&quot;Arg....&quot;)\n} }\n</code></pre>\n<p>The example code logs the original request url. The response is an HTTP 404. The body is <code>Arg....</code>.</p>\n<h3 id=\"logging\">Logging</h3>\n<p>Logging is based on standard Node.js functionality. <code>console.log(&quot;Hello&quot;)</code> sends &quot;Hello&quot; to the logs. As there is no graphical log tool available, use the command <code>kubectl</code> to display the logs.</p>\n<pre><code class=\"lang-sh\">$ kubectl logs -n &lt;environment&gt; -l function=&lt;function&gt; -c &lt;function&gt;\n</code></pre>\n"
    },
    {
      "order": "030-architecture-serverless",
      "title": "Architecture",
      "source": "<p>The term &quot;serverless&quot; refers to an architecture that is Internet-based. Application development that uses serverless technology relies solely on a combination of cloud-based, third-party services, client-side logic, and service-hosted remote procedure calls, also known as &quot;Functions as a Service&quot; or FaaS. Developers use lambdas to create this combination. As a result, this combination replaces the common use of a server. In the context of Kyma, lambda functions connect third-party services and Kyma. Developing with this serverless approach reduces the implementation and operation effort of an application to the absolute minimum.</p>\n<h2 id=\"the-serverless-architecture\">The Serverless architecture</h2>\n<p>The following diagram illustrates a generic serverless implementation.</p>\n<p><img src=\"assets/serverless_general.png\" alt=\"General serverless architecture\"></p>\n<p>The application flow takes place on the client side. Third parties handle the infrastructural logic. Custom logic can process updates and encapsulate databases. Authentication is an example of custom logic. Third parties can also handle business logic. A hosted database contains read-only data that the client reads. None of this functionality runs on a single, central server. Instead, the client relies on FaaS as its resource.</p>\n<p>The following diagram shows an example of tasks that lambdas can perform in Kyma after a user invokes them.</p>\n<p><img src=\"assets/lambda_example.png\" alt=\"Lambdas in Kyma\"></p>\n<p>First, the user invokes the exposed lambda endpoint. Then, the lambda function can carry out a number of tasks, such as:</p>\n<ul>\n<li>Retrieving cart information from Enterprise Commerce</li>\n<li>Retrieving stock details</li>\n<li>Updating a database</li>\n</ul>\n<h2 id=\"open-source-components\">Open source components</h2>\n<p>Kyma is comprised of several open source technologies to provide extensive functionality.</p>\n<h3 id=\"kubeless\">Kubeless</h3>\n<p>Kubeless is the serverless framework integrated into Kyma that allows you to deploy lambda functions. These functions run in Pods inside the Kubeless controller on a node, which can be a virtual or hardware machine.</p>\n<p>Kubeless also has a command line interface. Use Node.js to create lambda functions.</p>\n<h3 id=\"istio\">Istio</h3>\n<p>Istio is a third-party component that makes it possible to expose and consume services in Kyma. See the <a href=\"https://istio.io\" target=\"_blank\">Istio documentation</a> to learn more. Istio helps create a network of deployed services, called a service mesh.</p>\n<p>In Kyma, functions run in Pods. Istio provides a proxy for specified pods that talk to a pilot. The pilot confirms whether access to the pod is permissible as per the request. In the diagram, Pod B requests access to Pod A. Pod A has an Istio proxy that contains a set of instructions on which services can access Pod A. The Istio proxy also notifies Pod A as to whether Pod B is a part of the service mesh. The Istio Proxy gets all of its information from the Pilot.</p>\n<p><img src=\"assets/istio.png\" alt=\"Istio architecture\"></p>\n<h3 id=\"nats\">NATS</h3>\n<p>The Event Bus in Kyma monitors business events and trigger functions based on those events. At the heart of the Event Bus is NATS, an open source, stand-alone messaging system. To learn more about NATS, visit the <a href=\"https://nats.io\" target=\"_blank\">NATS website</a>.</p>\n<p>The following diagram demonstrates the Event Bus architecture.</p>\n<p><img src=\"assets/nats.png\" alt=\"Event Bus architecture\"></p>\n<p>The Event Bus exposes an HTTP endpoint that the system can consume. An external event, such as a subscription, triggers the Event Bus. A lambda function works with a push notification, and the subscription handling of the Event Bus processes the notification.</p>\n"
    },
    {
      "order": "040-cli-reference",
      "title": "CLI reference",
      "source": "<p>This section provides you with useful command line examples used in Kyma.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ul>\n<li><a href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl/\" target=\"_blank\">kubectl</a> 1.10.0</li>\n</ul>\n<p>To develop, deploy, or run functions directly download these tools additionally:</p>\n<ul>\n<li><a href=\"https://github.com/kubeless/kubeless/releases\" target=\"_blank\">Kubeless CLI</a></li>\n<li><a href=\"https://nodejs.org/en/download/\" target=\"_blank\">Node.js, version 6 or 8</a></li>\n</ul>\n<h3 id=\"set-the-cluster-domain-variable\">Set the cluster domain variable</h3>\n<p>The commands throughout this guide use URLs that require you to provide the domain of the cluster which you are using. To complete this configuration, set the variable <code>yourClusterDomain</code> to the domain of your cluster.</p>\n<p>For example if your cluster&#39;s domain is &#39;demo.cluster.kyma.cx&#39; then run the following command:</p>\n<pre><code class=\"lang-bash\">   export yourClusterDomain=&#39;demo.cluster.kyma.cx&#39;\n</code></pre>\n<h2 id=\"details\">Details</h2>\n<p>Use the command line to create, call, deploy, expose, and bind a function.</p>\n<h3 id=\"deploy-a-function-using-a-yaml-file-and-kubectl\">Deploy a function using a yaml file and kubectl</h3>\n<p>You can use the Kubeless CLI to deploy functions in Kyma.</p>\n<pre><code class=\"lang-bash\">$ kubectl apply -f https://minio.$yourClusterDomain/content/components/serverless/assets/deployment.yaml\n</code></pre>\n<p>Check if the function is available:</p>\n<pre><code class=\"lang-bash\">$ kubeless function list hello\n</code></pre>\n<h3 id=\"deploy-a-function-using-a-js-file-and-the-kubeless-cli\">Deploy a function using a JS file and the Kubeless CLI</h3>\n<p>You can deploy a function using the Kubernetes and Kubeless CLI. See the following example:</p>\n<pre><code class=\"lang-bash\">$ kubeless function deploy hello --runtime nodejs8 --handler hello.main --from-file https://minio.$yourClusterDomain/content/components/serverless/assets/hello.js --trigger-http\n</code></pre>\n<h3 id=\"call-a-function-using-the-cli\">Call a function using the CLI</h3>\n<p>Use the CLI to call a function:</p>\n<pre><code class=\"lang-bash\">$ kubeless function call hello\n</code></pre>\n<h3 id=\"expose-a-function-without-authentication\">Expose a function without authentication</h3>\n<p>Use the CLI to create an API for your function:</p>\n<pre><code class=\"lang-bash\">$ kubectl apply -f https://minio.$yourClusterDomain/content/components/serverless/assets/api-without-auth.yaml\n</code></pre>\n<h3 id=\"expose-a-function-with-authentication-enabled\">Expose a function with authentication enabled</h3>\n<p>If your function is deployed to a cluster run:</p>\n<pre><code class=\"lang-bash\"> curl -k https://minio.$yourClusterDomain/content/components/serverless/assets/api-with-auth.yaml | sed &quot;s/.kyma.local/.$yourClusterDomain/&quot; | kubectl apply -f -\n</code></pre>\n<p>If Kyma is running locally, add <code>hello.kyma.local</code> mapped to <code>minikube ip</code> to <code>/etc/hosts</code></p>\n<pre><code class=\"lang-bash\">$ echo &quot;$(minikube ip) hello.kyma.local&quot; | sudo tee -a /etc/hosts\n</code></pre>\n<p>Create the API for your function:</p>\n<pre><code class=\"lang-bash\">kubectl apply -f https://minio.$yourClusterDomain/content/components/serverless/assets/api-with-auth.yaml\n</code></pre>\n<h3 id=\"bind-a-function-to-events\">Bind a function to events</h3>\n<p>You can bind the function to Kyma and to third-party services. For details, refer to the <a href=\"../../service-catalog/docs/001-overview-service-catalog.md\">Service Catalog</a> documentation.</p>\n"
    }
  ]
}
