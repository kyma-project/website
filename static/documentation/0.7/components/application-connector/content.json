{
  "id": "application-connector",
  "displayName": "Application Connector",
  "description": "Overal documentation for Application Connector",
  "type": "Components",
  "docs": [
    {
      "order": "01-01-application-connector",
      "title": "Overview",
      "source": "<p>The Application Connector (AC) is a proprietary Kyma implementation that allows you to connect with external solutions. No matter if you want to integrate an on-premise or a cloud system, the integration process doesn&#39;t change, which allows to avoid any configuration or network-related problems.</p>\n<p>The external solution you connect to Kyma using the AC is represented as an Application (App). There is always a one-to-one relationship between a connected solution and an App, which helps to ensure the highest level of security and separation. This means that you must create five separate Apps in your cluster to connect five different external solutions and use their APIs and Event catalogs in Kyma.</p>\n<p>The AC gives you this functionality:</p>\n<ul>\n<li>Manages the lifecycle of Apps.</li>\n<li>Establishes a secure connection and generates the client certificate used by the connected external solution.</li>\n<li>Registers the APIs and the Event catalogs of the connected external solution.</li>\n<li>Delivers the Events from the connected external solution to the Kyma Event Bus.</li>\n<li>Proxies calls sent from Kyma to external APIs registered by the connected external solution.</li>\n<li>Allows to map an App to a Kyma Namespace and use its registered APIs and Event catalogs in the context of that Namespace.</li>\n<li>Integrates the registered APIs and Event catalogs with the Kyma Service Catalog.</li>\n</ul>\n<p>All of the AC components scale independently, which allows to adjust it to fit the needs of the implementation built using Kyma.</p>\n<blockquote>\n<p><strong>NOTE:</strong> To learn more about the concept of Namespaces in Kyma, read <a href=\"/root/kyma#details-namespaces\">this</a> document.</p>\n</blockquote>\n"
    },
    {
      "order": "02-01-application-connector",
      "title": "Application Connector components",
      "type": "Architecture",
      "source": "<p><img src=\"./assets/001-application-connector.svg\" alt=\"Architecture Diagram\"></p>\n<h2 id=\"nginx-ingress-controller\">Nginx Ingress Controller</h2>\n<p>The Nginx Ingress Controller exposes the Application Connector by assigning a public IP address and a DNS name to it.\nThe DNS name of the Ingress is cluster-dependant and follows the <code>gateway.{cluster-dns}</code> format, for example <code>gateway.servicemanager.cluster.kyma.cx</code>.\nYou can access every exposed Application (App) through its Gateway by using the assigned path. For example, to reach the Gateway for the <code>user-custom</code> App, use this URL: <code>gateway.servicemanager.cluster.kyma.cx/user-custom</code>. The Nginx Ingress Controller secures the endpoint with certificate validation. Each call must include a valid client certificate which is App-specific.</p>\n<h2 id=\"connector-service\">Connector Service</h2>\n<p>The Connector Service:</p>\n<ul>\n<li>Handles the exchange of client certificates for a given RE.</li>\n<li>Provides the Application Registry and Event Service endpoints.</li>\n<li>Signs client certificates using the server side certificate stored in Kubernetes Secrets.</li>\n</ul>\n<h2 id=\"application-registry\">Application Registry</h2>\n<p>The Application Registry stores all registered APIs and Event Catalog exposed by a connected external solution. The APIs and Event catalogs metadata are stored in the <a href=\"#custom-resource-application\">Application</a> custom resource.\nThe system creates a new Kubernetes service for each registered API. Additionally, a new Service Classes is registered in the Service Catalog.</p>\n<blockquote>\n<p><strong>NOTE:</strong> Using the Application Registry, you can register an API along with its OAuth or Basic Authentication credentials. The credentials are stored in a Kubernetes Secret.</p>\n</blockquote>\n<h2 id=\"event-service\">Event Service</h2>\n<p>The Event Service sends Events to the Kyma Event Bus and enriches the Events with metadata that indicates the source of the Event.\nThis allows routing the Events to lambda functions and services based on their source App.</p>\n<h2 id=\"application\">Application</h2>\n<p>An App represents an external solution connected to Kyma. It handles the integration with other components, such as the Service Catalog or the Event Bus.\nUsing the components of the Application Connector, the App creates a coherent identity for a connected external solution and ensures its separation.\nAll Apps are created through the Application custom resource, which also stores all of the relevant metadata. You can map an App to many Kyma Namespaces and use the APIs and the Event Catalogs of the connected external solution within their context.</p>\n<h2 id=\"application-broker\">Application Broker</h2>\n<p>The Application Broker (AB) watches all <a href=\"#custom-resource-application\">Application</a> custom resources. These custom resources contain definitions of external solutions’ APIs and Events. The AB exposes those APIs and Events definitions as ServiceClasses to the Service Catalog. When the list of remote ServiceClasses is available in the Service Catalog, you can create an ApplicationMapping, provision those ServiceClasses, and enable them for Kyma services. This allows you to extend the functionality of existing systems.</p>\n<p>The AB implements the <a href=\"https://www.openservicebrokerapi.org/\" target=\"_blank\">Open Service Broker API</a>. For more details about Service Brokers, see <a href=\"/docs/components/helm-broker#overview-service-brokers\">this</a> documentation.</p>\n<h2 id=\"application-operator\">Application Operator</h2>\n<p>The operator listens for creating or deleting the Application custom resources and acts accordingly, either provisioning or de-provisioning an instance of Application Proxy and Event Service for every custom resource.         </p>\n<blockquote>\n<p><strong>NOTE:</strong> Every Application custom resource corresponds to a single App to which you can connect an external solution.</p>\n</blockquote>\n<h2 id=\"application-proxy\">Application Proxy</h2>\n<p>The Application Proxy is an intermediary component between a lambda function or a service and an external API registered with the Application Registry. It can call services secured with:</p>\n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc7617\" target=\"_blank\">Basic Authentication</a> mechanism,</li>\n<li>OAuth</li>\n<li>Client certificates</li>\n</ul>\n<h2 id=\"access-service\">Access Service</h2>\n<p>The Access Service exposes the Application Proxy and manages the access from the Lambda functions and services deployed in Kyma to the external APIs over the Application Proxy.</p>\n<h2 id=\"minio-bucket\">Minio bucket</h2>\n<p>The Minio bucket stores the documentation of the connected external solution&#39;s registered APIs and Event catalogs.</p>\n<h2 id=\"kubernetes-secret\">Kubernetes Secret</h2>\n<p>The Kubernetes Secret is a Kubernetes object which stores sensitive data, such as the OAuth credentials.</p>\n"
    },
    {
      "order": "02-02-connector-service",
      "title": "Connector Service",
      "type": "Architecture",
      "source": "<p>The Connector Service generates client certificates which secure the communication between Kyma and the connected external solutions.        </p>\n<p>Generating a new client certificate is the first step in the process of configuring an Application (App). Kyma stores the root certificate and serves as the Certificate Authority when you configure a new App. When you generate a new client certificate, the Connector Service returns it along with the root certificate to allow validation.  </p>\n<p>This diagram illustrates the client certificate generation flow in details:\n<img src=\"./assets/002-automatic-configuration.svg\" alt=\"Client certificate generation operation flow\"></p>\n<ol>\n<li>The administrator requests for a token using the CLI or the UI and receives a link with the token, which is valid for a limited period of time.</li>\n<li>The administrator passes the token to the external system, which requests for information regarding the Kyma installation. In the response, it receives the following information:<ul>\n<li>the URL to which a third-party solution sends its Certificate Signing Request (CSR)</li>\n<li>URLs of the available APIs</li>\n<li>information required to generate a CSR</li>\n</ul>\n</li>\n<li>The external system generates a CSR based on the information provided by Kyma and sends the CSR to the designated URL. In the response, the external system receives a signed certificate. It can use the certificate to authenticate and safely communicate with Kyma.</li>\n</ol>\n"
    },
    {
      "order": "02-03-proxy-service",
      "title": "Application Proxy",
      "type": "Architecture",
      "source": "<p>The Application Proxy sends the requests from Lambda functions and services in Kyma to external APIs registered with the Application Registry. The Application Proxy works in conjunction with the Access Service, which exposes the Application Proxy.</p>\n<blockquote>\n<p><strong>NOTE:</strong> The system creates an Access Service for every external API registered by the Application Registry.</p>\n</blockquote>\n<p>The following diagram illustrates how the Application Proxy interacts with other components and external APIs secured with OAuth.</p>\n<p><img src=\"./assets/003-architecture-proxy-service.svg\" alt=\"Proxy Service Diagram\"></p>\n<ol>\n<li>A lambda function calls the Access Service. The name of every Access Service follows this format: <code>app-{application-name}-{service-id}</code></li>\n<li>The Access Service exposes the Application Proxy.</li>\n<li>The Application Proxy extracts the Application name and the service ID from the name of the Access Service name. Using the extracted Application name, the Application Proxy finds the respective Application custom resource and obtains the information about the registered external API, such as the API URL and the OAuth server URL.</li>\n<li>The Application Proxy gets a token from the OAuth server.</li>\n<li>The Application Proxy calls the target API using the OAuth token.  </li>\n</ol>\n<h2 id=\"caching\">Caching</h2>\n<p>To ensure optimal performance, the Application Proxy caches the OAuth tokens it obtains. If the service doesn&#39;t find a token valid for the call it makes, it gets a new token from the OAuth server.\nAdditionally, the service caches ReverseProxy objects used to proxy the requests to the underlying URL.</p>\n"
    },
    {
      "order": "02-04-application-broker",
      "title": "Application Broker",
      "type": "Architecture",
      "source": "<p>The Application Broker (AB) workflow consists of the following steps:</p>\n<ol>\n<li>The Application Broker watches for Applications (Apps) in the cluster and ApplicationMappings (AMs) in all Namespaces.</li>\n<li>The user creates an ApplicationMapping custom resource in a given Namespace. The AM activates services offered by an App. The AM must have the same name as the App.</li>\n<li>The Application Broker creates an <code>application-broker</code> Service Broker (SB) inside the Namespace in which the AM is created. This Service Broker contains data of all services provided by the activated Applications. There is always only one <code>application-broker</code> Service Broker per Namespace, even if there are more AMs.</li>\n<li>The Service Catalog fetches services that the <code>application-broker</code> Service Broker exposes.</li>\n<li>The Service Catalog creates a ServiceClass for each service received from the Service Broker.</li>\n</ol>\n<p><img src=\"./assets/004-AB-architecture.svg\" alt=\"AB architecture\"></p>\n<p>When this process is complete, you can provision and bind your services.</p>\n<h2 id=\"provisioning-and-binding-for-an-api-serviceclass\">Provisioning and binding for an API ServiceClass</h2>\n<p>This ServiceClass has a <strong>bindable</strong> flag set to <code>true</code> which means that you have to provision a ServiceInstance and bind it to the service or lambda to connect to the given API. The provisioning and binding workflow for an API ServiceClass consists of the following steps:</p>\n<ol>\n<li>Select an API ServiceClass from the Service Catalog.</li>\n<li>Provision this ServiceClass by creating its ServiceInstance in a Namespace.</li>\n<li>Bind your ServiceInstance to the service or lambda. During the binding process, ServiceBinding and ServiceBindingUsage resources are created.<ul>\n<li>ServiceBinding contains a Secret with a GatewayURL required to connect to the given API.</li>\n<li>ServiceBindingUsage injects the Secret, together with the label given during the registration process, to the lambda or service.</li>\n</ul>\n</li>\n<li>The service or lambda calls the API through the Application Connector. The Application Connector verifies the label to check if you have the authorization to access this API.</li>\n<li>After verifying the label, the Application Connector allows you to access the Application API.</li>\n</ol>\n<p><img src=\"./assets/005-AB-API-service-class.svg\" alt=\"API Service Class\"></p>\n<h2 id=\"provisioning-and-binding-for-an-event-serviceclass\">Provisioning and binding for an Event ServiceClass</h2>\n<p>This ServiceClass has a <strong>bindable</strong> flag set to <code>false</code> which means that after provisioning a ServiceClass in the Namespace, given Events are ready to use for all services. The provisioning workflow for an Event ServiceClass consists of the following steps:</p>\n<ol>\n<li>Select a given Event ServiceClass from the Service Catalog.</li>\n<li>Provision this ServiceClass by creating a ServiceInstance in the given Namespace.</li>\n<li>During the provisioning process, the EventActivation resource is created together with the ServiceInstance. EventActivation allows you to create an Event Bus Subscription.</li>\n<li>A Subscription is a custom resource by which an Event Bus triggers the lambda for a particular type of Event in this step.</li>\n<li>The Application sends an Event to the Application Connector.</li>\n<li>The Application Connector sends an Event to the lambda through the Event Bus.</li>\n</ol>\n<p><img src=\"./assets/006-AB-event-service-class.svg\" alt=\"Event Service Class\"></p>\n<h2 id=\"provisioning-and-binding-for-both-the-api-and-event-serviceclass\">Provisioning and binding for both the API and Event ServiceClass</h2>\n<p>This ServiceClass has a <strong>bindable</strong> flag set to <code>true</code>.\nThe provisioning and binding workflow for both the API and Event ServiceClass is a combination of steps described for an <a href=\"#architecture-the-application-broker-architecture-provisioning-and-binding-for-an-api-serviceclass\">API ServiceClass</a> and an <a href=\"#architecture-the-application-broker-architecture-provisioning-and-binding-for-an-event-serviceclass\">Event ServiceClass</a>.</p>\n"
    },
    {
      "order": "03-01-ac-security",
      "title": "Security",
      "type": "Details",
      "source": "<h2 id=\"client-certificates\">Client certificates</h2>\n<p>To provide maximum security, the Application Connector uses TLS protocol with Client Authentication enabled. As a result, whoever wants to connect to the Application Connector must present a valid client certificate, which is dedicated to a specific Application (App). In this way, the traffic is fully encrypted and the client has a valid identity.</p>\n<h2 id=\"disable-ssl-certificate-verification\">Disable SSL certificate verification</h2>\n<p>You can disable the SSL certificate verification in the communication between Kyma and an App to allow Kyma to send requests and data to an unsecured App. Disabling the certificate verification can be useful in certain testing scenarios.</p>\n<blockquote>\n<p><strong>NOTE:</strong> By default, the SSL certificate verification is enabled when sending data and requests to every App.</p>\n</blockquote>\n<p>Follow these steps to disable SSL certificate verification for communication between Kyma and an existing App:</p>\n<ol>\n<li>Edit the <code>{APPLICATION}-application-proxy</code> Deployment in the <code>kyma-integration</code> Namespace. Run:<pre><code>kubectl -n kyma-integration edit deployment {APPLICATION}-application-proxy\n</code></pre></li>\n<li>Edit the Deployment in Vim. Select <code>i</code> to start editing.</li>\n<li>Find the <strong>skipVerify</strong> parameter and change its value to <code>true</code>.</li>\n<li>Select <code>esc</code>, type <code>:wq</code>, and select <code>enter</code> to write and quit.</li>\n</ol>\n<h2 id=\"override-the-api-security-type\">Override the API security type</h2>\n<p>The Application Registry allows you to register APIs:</p>\n<ul>\n<li>Secured with <a href=\"https://tools.ietf.org/html/rfc7617\" target=\"_blank\">Basic Authentication</a></li>\n<li>Secured with OAuth flow</li>\n<li>Secured with client certificates</li>\n<li>Not secured</li>\n</ul>\n<p>The Application Proxy calls the registered APIs accordingly, basing on the security type specified in the API registration process.</p>\n<p>The Application Proxy overrides the registered APIs security type if it gets a request which contains the <strong>Access-Token</strong> header. In such a case, the Application Proxy rewrites the token from the <strong>Access-Token</strong> header into an OAuth-compliant <strong>Authorization</strong> header and forwards it to the target API.</p>\n<p>This mechanism is suited for implementations in which an external application handles user authentication.</p>\n<p>See <a href=\"https://github.com/kyma-project/examples/tree/master/call-ec\" target=\"_blank\">this</a> example to see such an implementation in action.</p>\n"
    },
    {
      "order": "03-02-access-ac-on-local",
      "title": "Access the Application Connector on a local Kyma deployment",
      "type": "Details",
      "source": "<p>To access the Application Connector on a local deployment of Kyma, you must add the Kyma server certificate to the trusted certificate storage of your programming environment. This is necessary to connect the external solution to your local Kyma deployment, allow client certificate exchange, and API registration.</p>\n<p>For example, to access the Application Connector from a Java environment, run this command to add the Kyma server certificate to the Java Keystore:</p>\n<pre><code>sudo {JAVA_HOME}/bin/keytool -import -alias “Kyma” -keystore {JAVA_HOME}/jre/lib/security/cacerts -file {KYMA_HOME}/installation/certs/workspace/raw/server.crt\n</code></pre>"
    },
    {
      "order": "03-03-consume-services",
      "title": "Consume applications through the Service Catalog",
      "type": "Details",
      "source": "<p>To consume an external solution connected to Kyma, you must register it as an Application (App). As a result of registering the external solution, ClusterServiceClasses are created in the Service Catalog.</p>\n<h2 id=\"external-solution-s-services-in-the-service-catalog\">External solution&#39;s services in the Service Catalog</h2>\n<p>The Example API is registered in Kyma with the <code>targetUrl</code> pointing to <code>https://www.orders.com/v1/orders</code>. The ID assigned to the API in the registration process is <code>01a702b8-e302-4e62-b678-8d361b627e49</code>.</p>\n<p>The Application Broker, which provides ServiceClasses to the Service Catalog, follows this naming convention for its objects:</p>\n<pre><code>app-{application-name}-{service-id}\n</code></pre><p>The <code>{service-id}</code> is the service identifier assigned in the process of registration. The <code>{application}</code> is the name of the App created in Kyma. It represents an instance of the connected external solution that owns the registered service. Such identifier used by the Application Broker is referred to as the <code>name</code> of a ClusterServiceClass in the Service Catalog.</p>\n<p>This an example of a full ClusterServiceClass <code>name</code>:</p>\n<pre><code>re-ec-default-01a702b8-e302-4e62-b678-8d361b627e49\n</code></pre><h2 id=\"service-consumption\">Service consumption</h2>\n<p>After you provision the Example API in the Namespace of your choice using the Service Catalog, you can bind it to your application and consume it by calling the URL you get as a result of a successful binding.</p>\n<p>This is a sample URL for the Example API:</p>\n<pre><code>re-ec-default-01a702b8-e302-4e62-b678-8d361b627e49.kyma-integration/orders\n</code></pre><p>When you call this URL, the Application Proxy passes all requests to the <code>https://www.orders.com/v1/orders</code> address, which is the <code>targetUrl</code> registered for the Example API. You do not have to get an OAuth token and manually include it in the call as the Application Proxy does it for you automatically.</p>\n"
    },
    {
      "order": "03-04-metadata-service",
      "title": "Application Registry",
      "type": "Details",
      "source": "<p>The Application Registry allows you to register the APIs and Event catalogs of the services exposed by the connected external solution.         </p>\n<p>The Application Registry stores the data of all registered services in:</p>\n<ul>\n<li>Application custom resource (CR), which stores the metadata of the service.</li>\n<li>Minio bucket, which stores the API specification, Event catalog and documentation.</li>\n<li>Kubernetes secrets, which stores sensitive data, such as OAuth credentials.</li>\n</ul>\n<h2 id=\"kubernetes-apis-interaction\">Kubernetes APIs interaction</h2>\n<p>The Application Registry interacts with Kubernetes APIs to perform these tasks:</p>\n<ul>\n<li>Modify the Application CR instance.</li>\n<li>Create Secrets which contain client ID and client secret used to access OAuth-secured APIs.</li>\n<li>Create the Access Service.</li>\n</ul>\n"
    },
    {
      "order": "03-05-pass-access-token-in-request-header",
      "title": "Pass an access token in a request header",
      "type": "Details",
      "source": "<p>The Application Connector supports passing the access token directly in the request.</p>\n<h2 id=\"passing-the-access-token\">Passing the access token</h2>\n<p>If the user is already authenticated to the service deployed on Kyma, the access token can be passed in a custom <code>Access-token</code> header. If the Application Connector detects that the custom header is present, instead of obtaining a new token, it passes the received one as a <code>Bearer</code> token in the <code>Authorization</code> header.</p>\n<h2 id=\"example\">Example</h2>\n<p>Find the example of passing the EC access token to the Application Connector using lambda in the <a href=\"https://github.com/kyma-project/examples/tree/master/call-ec\" target=\"_blank\"><code>examples</code></a> repository.</p>\n"
    },
    {
      "order": "06-01-application",
      "title": "Application",
      "type": "Custom Resource",
      "source": "<p>The <code>applications.applicationconnector.kyma-project.io</code> CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to register an Application (App) in Kyma. The <code>Application</code> custom resource defines the APIs that the App offers. After creating a new custom resource for a given App, the App is mapped to appropriate ServiceClasses in the Service Catalog. To get the up-to-date CRD and show the output in the <code>yaml</code> format, run this command:</p>\n<pre><code>kubectl get crd applications.applicationconnector.kyma-project.io -o yaml\n</code></pre><h2 id=\"sample-custom-resource\">Sample custom resource</h2>\n<p>This is a sample resource that registers the <code>re-prod</code> App which offers one service.</p>\n<pre><code>apiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: Application\nmetadata:\n  name: system_prod\nspec:\n  description: This is the system_production Application.\n  labels:\n    region: us\n    kind: production\n</code></pre><h2 id=\"custom-resource-parameters\">Custom resource parameters</h2>\n<p>This table lists all the possible parameters of a given resource together with their descriptions:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Parameter</th>\n<th style=\"text-align:center\">Mandatory</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>metadata.name</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the name of the CR.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.description</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Describes the connected Application.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.accessLabel</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Labels the App when an ApplicationMapping is created.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.labels</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Defines the labels of the App.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Contains all services that the Application provides.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.id</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Identifies the service that the Application provides.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.identifier</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Provides an additional identifier of the ServiceClass.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.name</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Represents a unique name of the service used by the Service Catalog.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.displayName</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies a human-readable name of the Application service. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.description</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Provides a short, human-readable description of the service offered by the App. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.longDescription</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Provides a longer, human-readable description of the service offered by the App. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.providerDisplayName</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies a human-readable name of the Application service provider. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.tags</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies additional tags used for better documentation of the available APIs. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.labels</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies additional labels for the service offered by the App. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Contains the information about the APIs and Events that the service offered by the App provides. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries.type</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the entry type: API or Event. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries.gatewayUrl</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies the URL of the Application Connector. This field is required for the API entry type. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries.accessLabel</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies the label used in Istio rules in the Application Connector. This field is required for the API entry type.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries.targetUrl</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies the URL of a given API. This field is required for the API entry type. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries.oauthUrl</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies the URL used to authorize with a given API. This field is required for the API entry type. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.services.entries.credentialsSecretName</strong></td>\n<td style=\"text-align:center\"><strong>NO</strong></td>\n<td style=\"text-align:left\">Specifies the name of the Secret which allows you to call a given API. This field is required if <strong>spec.services.entries.oauthUrl</strong> is specified. Parameter provided by the Application Registry, do not edit.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"additional-information\">Additional information</h2>\n<p>The Application Operator adds the <strong>status</strong> section which describes the status of the App installation to the created CR periodically. This table lists the fields of the <strong>status</strong> section.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>status.installationStatus</strong></td>\n<td style=\"text-align:center\">Describes the status of the App installation.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>status.installationStatus.description</strong></td>\n<td style=\"text-align:center\">Provides a longer description of the installation status.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>status.installationStatus.status</strong></td>\n<td style=\"text-align:center\">Provides a short, human-readable description of the installation status.</td>\n</tr>\n</tbody>\n</table>\n"
    },
    {
      "order": "06-02-apllicationmapping",
      "title": "ApplicationMapping",
      "type": "Custom Resource",
      "source": "<p>The <code>applicationmappings.application.kyma-project.io</code> CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to enable APIs and Events from an Application (App) as a ServiceClass in a given Namespace. To get the up-to-date CRD and show the output in the <code>yaml</code> format, run this command:</p>\n<pre><code>kubectl get crd applicationmappings.applicationconnector.kyma-project.io -o yaml\n</code></pre><h2 id=\"sample-custom-resource\">Sample custom resource</h2>\n<p>This is a sample ApplicationMapping resource which enables the <code>test</code> Application in the <code>production</code> Namespace:</p>\n<pre><code>apiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: ApplicationMapping\nmetadata:\n  name: test\n  namespace: production\n</code></pre><h2 id=\"custom-resource-parameters\">Custom resource parameters</h2>\n<p>This table lists all the possible parameters of a given resource together with their descriptions:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Parameter</th>\n<th style=\"text-align:center\">Mandatory</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>metadata.name</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the name of the CR and the App.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>metadata.namespace</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the Namespace in which the App is enabled.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"related-resources-and-components\">Related resources and components</h2>\n<p>These are the resources related to this CR:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Custom resource</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ApplicationMapping</td>\n<td style=\"text-align:left\">Uses this CR to expose the services of an App in a given Namespace.</td>\n</tr>\n</tbody>\n</table>\n<p>These components use this CR:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Component</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Application Broker</td>\n<td style=\"text-align:left\">Uses this CR to enable the provisioning of ServiceClasses in a given Namespace.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UI API Layer</td>\n<td style=\"text-align:left\">Uses this CR to filter the enabled Apps. It also allows you to create or delete ApplicationMappings.</td>\n</tr>\n</tbody>\n</table>\n"
    },
    {
      "order": "06-03-event-activation",
      "title": "EventActivation",
      "type": "Custom Resource",
      "source": "<p>The <code>eventactivations.applicationconnector.kyma-project.io</code> CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to create an Event Bus Subscription and to get an Event schema. To get the up-to-date CRD and show the output in the <code>yaml</code> format, run this command:</p>\n<pre><code>kubectl get crd eventactivations.applicationconnector.kyma-project.io -o yaml\n</code></pre><h2 id=\"sample-custom-resource\">Sample custom resource</h2>\n<p>This is a sample resource that allows you to consume Events sent from the service with the <code>ac031e8c-9aa4-4cb7-8999-0d358726ffaa</code> ID in a <code>production</code> Namespace.</p>\n<pre><code>apiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: EventActivation\nmetadata:\n  name: &quot;ac031e8c-9aa4-4cb7-8999-0d358726ffaa&quot;\n  namespace: production\nspec:\n  displayName: &quot;Orders&quot;\n  sourceId: &quot;prod&quot;\n</code></pre><h2 id=\"custom-resource-parameters\">Custom resource parameters</h2>\n<p>This table lists all the possible parameters of a given resource together with their descriptions:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Parameter</th>\n<th style=\"text-align:center\">Mandatory</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>metadata.name</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the name of the CR and the ID of the Application service. This field is also used to fetch Event schemas from the Minio storage.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>metadata.namespace</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the Namespace in which the CR is created.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.displayName</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies a human-readable name of the Application service.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>spec.sourceId</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Used to construct a Publish-Subscribe (Pub/Sub) topic name where the Events are send and from where the Events are consumed.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"related-resources-and-components\">Related resources and components</h2>\n<p>These are the resources related to this CR:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Custom resource</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Application</td>\n<td style=\"text-align:left\">Describes a service from which the user receives Events.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Subscription</td>\n<td style=\"text-align:left\">Contains information on how to create an infrastructure for consuming Events. Works only if the EventActivation is enabled.</td>\n</tr>\n</tbody>\n</table>\n<p>These components use this CR:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Component</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Application Broker</td>\n<td style=\"text-align:left\">Uses this CR to enable the user to receive Events from a given service.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Event Bus</td>\n<td style=\"text-align:left\">Uses this CR to control the consumption of an Event.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Serverless</td>\n<td style=\"text-align:left\">Lambda UI sends a GraphQL query to UI API Layer to list EventActivations.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UI API Layer</td>\n<td style=\"text-align:left\">Exposes the given CR to the Console UI.</td>\n</tr>\n</tbody>\n</table>\n"
    },
    {
      "order": "06-04-tokenrequest",
      "title": "TokenRequest",
      "type": "Custom Resource",
      "source": "<p>The <code>tokenrequests.applicationconnector.kyma-project.io</code> CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to request token for Application (App) configuration URL from the Connector Service. To get the up-to-date CRD and show the output in the <code>yaml</code> format, run this command:</p>\n<pre><code>kubectl get crd tokenrequests.applicationconnector.kyma-project.io -o yaml\n</code></pre><h2 id=\"sample-custom-resource\">Sample custom resource</h2>\n<p>This is a sample custom resource (CR) which allows to get the configuration required to connect an external solution to the <code>test</code> App.</p>\n<pre><code>apiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: TokenRequest\nmetadata:\n  name: test\n</code></pre><h2 id=\"custom-resource-parameters\">Custom resource parameters</h2>\n<p>This table lists all the possible parameters of a given resource together with their descriptions:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Parameter</th>\n<th style=\"text-align:center\">Mandatory</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>metadata.name</strong></td>\n<td style=\"text-align:center\"><strong>YES</strong></td>\n<td style=\"text-align:left\">Specifies the name of the CR and the App to request token for.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"additional-information\">Additional information</h2>\n<p>When you fetch an existing TokenRequest CR, the system adds the <strong>status</strong> section which describes the status of the request and lists the configuration details. This table lists the fields of the <strong>status</strong> section.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>status.expireAfter</strong></td>\n<td style=\"text-align:center\">Date and time after wich the token will expire and the controller will delete the CR.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>status.application</strong></td>\n<td style=\"text-align:center\">The name of the App for which the token was issued.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>status.state</strong></td>\n<td style=\"text-align:center\">Status of the token request. This field can have one of two values: <code>OK</code> or <code>ERR</code>.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>status.token</strong></td>\n<td style=\"text-align:center\">The token generated by the Connector Service.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>status.url</strong></td>\n<td style=\"text-align:center\">The URL to the Connector Service info endpoint with the token.</td>\n</tr>\n</tbody>\n</table>\n"
    },
    {
      "order": "08-01-create-application",
      "title": "Create a new Application",
      "type": "Tutorials",
      "source": "<p>The Application Operator listens for the creation of Application custom resources. It provisions and de-provisions the necessary deployments for every created Application (App).</p>\n<blockquote>\n<p><strong>NOTE:</strong> An App represents a single connected external solution.</p>\n</blockquote>\n<p>To create a new App, run this command:</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: Application\nmetadata:\n  name: {APP_NAME}\nspec:\n  description: {APP_DESCRIPTION}\n  labels:\n    region: us\n    kind: production\nEOF\n</code></pre><h2 id=\"check-the-app-status\">Check the App status</h2>\n<p>To check the status of the created App and show the output in the <code>yaml</code> format, run this command:</p>\n<pre><code>kubectl get app {APP_NAME} -o yaml\n</code></pre><p>A successful response returns the Application custom resource with the specified name. The custom resource has the <strong>status</strong> section added.\nThis is an example response:</p>\n<pre><code>apiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: Application\nmetadata:\n  clusterName: &quot;&quot;\n  creationTimestamp: 2018-11-22T13:53:20Z\n  generation: 1\n  name: test1\n  namespace: &quot;&quot;\n  resourceVersion: &quot;30728&quot;\n  selfLink: /apis/applicationconnector.kyma-project.io/v1alpha1/applications/test1\n  uid: f8ca5595-ee5d-11e8-acb2-000d3a443243\nspec:\n  accessLabel: {APP_NAME}\n  description: {APP_DESCRIPTION}\n  labels: {}\n  services: []\nstatus:\n  installationStatus:\n    description: Installation complete\n    status: DEPLOYED\n</code></pre>"
    },
    {
      "order": "08-02-get-client-certificate",
      "title": "Get the client certificate",
      "type": "Tutorials",
      "source": "<p>After you create an Application (App), connect it to an external solution to consume the solution&#39;s APIs and Event catalogs in Kyma. To accomplish this, get the client certificate for the external solution and register its services.</p>\n<p>This guide shows you how to get the client certificate.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ul>\n<li><a href=\"https://www.openssl.org/docs/man1.0.2/apps/openssl.html\" target=\"_blank\">OpenSSL toolkit</a> to create a Certificate Signing Request (CSR), keys, and certificates which fulfil high security standards.</li>\n</ul>\n<h2 id=\"get-the-configuration-url-with-a-token\">Get the configuration URL with a token</h2>\n<p>To get the configuration URL which allows you to fetch the required configuration details, create a TokenRequest custom resource (CR). The controller which handles this CR kind adds the <strong>status</strong> section to the created CR. The <strong>status</strong> section contains the required configuration details.</p>\n<ul>\n<li><p>Create a TokenRequest CR. The CR name must match the name of the App for which you want to get the configuration details. Run:</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: TokenRequest\nmetadata:\n  name: {APP_NAME}\nEOF\n</code></pre></li>\n<li><p>Fetch the TokenRequest CR you created to get the configuration details from the <strong>status</strong> section. Run:</p>\n<pre><code>kubectl get tokenrequest.applicationconnector.kyma-project.io {APP_NAME} -o yaml\n</code></pre><blockquote>\n<p><strong>NOTE:</strong> If the response doesn&#39;t contain the <strong>status</strong> section, wait for a few moments and fetch the CR again.</p>\n</blockquote>\n</li>\n</ul>\n<p>A successful call returns the following response:</p>\n<pre><code>  apiVersion: applicationconnector.kyma-project.io/v1alpha1\n  kind: TokenRequest\n  metadata:\n    name: {APP_NAME}\n  status:\n    expireAfter: 2018-11-22T18:38:44Z\n    application: {APP_NAME}\n    state: OK\n    token: h31IwJiLNjnbqIwTPnzLuNmFYsCZeUtVbUvYL2hVNh6kOqFlW9zkHnzxYFCpCExBZ_voGzUo6IVS_ExlZd4muQ==\n    url: https://connector-service.kyma.local/v1/applications/signingRequests/info?token=h31IwJiLNjnbqIwTPnzLuNmFYsCZeUtVbUvYL2hVNh6kOqFlW9zkHnzxYFCpCExBZ_voGzUo6IVS_ExlZd4muQ==\n</code></pre><h2 id=\"get-the-csr-information-and-configuration-details-from-kyma\">Get the CSR information and configuration details from Kyma</h2>\n<p>Use the link you got in the previous step to fetch the CSR information and configuration details required to connect your external solution. Run:</p>\n<pre><code>curl {CONFIGURATION_URL_WITH_TOKEN}\n</code></pre><blockquote>\n<p><strong>NOTE:</strong> The URL you call in this step contains a token that is valid for 5 minutes or for a single call. You get a code <code>403</code> error if you call the same configuration URL more than once, or if you call an URL with an expired token.</p>\n</blockquote>\n<p>A successful call returns the following response:</p>\n<pre><code>{\n    &quot;csrUrl&quot;: &quot;{CSR_SIGNING_URL_WITH_TOKEN}&quot;,\n    &quot;api&quot;:{\n        &quot;metadataUrl&quot;:      &quot;https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/services&quot;,\n        &quot;eventsUrl&quot;:        &quot;https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/events&quot;,\n        &quot;infoUrl&quot;:          &quot;https://connector-service.kyma.local/v1/applications/management/info&quot;,\n        &quot;certificatesUrl&quot;:  &quot;https://connector-service.{CLUSTER_DOMAIN}/v1/applications/certificates&quot;,\n    },\n    &quot;certificate&quot;:{\n        &quot;subject&quot;:&quot;OU=Test,O=TestOrg,L=Waldorf,ST=Waldorf,C=DE,CN={APP_NAME}&quot;,\n        &quot;extensions&quot;: &quot;&quot;,\n        &quot;key-algorithm&quot;: &quot;rsa2048&quot;,\n    }\n}\n</code></pre><h2 id=\"generate-a-csr-and-send-it-to-kyma\">Generate a CSR and send it to Kyma</h2>\n<p>Generate a CSR using the certificate subject data obtained in the previous step:</p>\n<pre><code>openssl genrsa -out generated.key 2048\nopenssl req -new -sha256 -out generated.csr -key generated.key -subj &quot;/OU=Test/O=TestOrg/L=Waldorf/ST=Waldorf/C=DE/CN={APP_NAME}&quot;\nopenssl base64 -in generated.csr\n</code></pre><p>Send the encoded CSR to Kyma. Run:</p>\n<pre><code>curl -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;csr&quot;:&quot;BASE64_ENCODED_CSR_HERE&quot;}&#39; {CSR_SIGNING_URL_WITH_TOKEN}\n</code></pre><p>The response contains a valid client certificate signed by the Kyma Certificate Authority.</p>\n<pre><code>{\n    &quot;crt&quot;:&quot;BASE64_ENCODED_CRT&quot;\n}\n</code></pre><p>After you receive the certificate, decode it and use it in your application. Register the services of your external solution through the Application Registry.</p>\n<h2 id=\"call-the-metadata-and-event-services-on-local-deployment\">Call the Metadata and Event services on local deployment</h2>\n<p>When you connect an external solution to a local Kyma deployment, you must pass the NodePort of the <code>application-connector-nginx-ingress-controller</code> to successfully call the Metadata Service and the Event Service.</p>\n<ul>\n<li>To get the NodePort, run:<pre><code>kubectl -n kyma-system get svc application-connector-nginx-ingress-controller -o &#39;jsonpath={.spec.ports[?(@.port==443)].nodePort}&#39;\n</code></pre></li>\n<li>When you send requests to the Metadata Service and the Event Service, pass the NodePort along with the generated certificate and key. For example:<pre><code>curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/metadata/services --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n</code></pre><pre><code>curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/events --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n</code></pre></li>\n</ul>\n"
    },
    {
      "order": "08-03-register-manage-services",
      "title": "Register a service",
      "type": "Tutorials",
      "source": "<p>This guide shows you how to register a service of your external solution in Kyma.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>Valid certificate signed by the Kyma Certificate Authority.</p>\n<h2 id=\"register-a-service\">Register a service</h2>\n<ol>\n<li><p>To register a service with a Basic Authentication-secured API, follow this template to prepare the request body:</p>\n<blockquote>\n<p><strong>NOTE:</strong> Follow <a href=\"#tutorials-register-a-secured-api\">this</a> tutorial to learn how to register APIs secured with different security schemes.</p>\n</blockquote>\n<pre><code>{\n &quot;provider&quot;: &quot;example-provider&quot;,\n &quot;name&quot;: &quot;example-name&quot;,\n &quot;description&quot;: &quot;This is the long description of your service&quot;,\n &quot;shortDescription&quot;: &quot;Short description&quot;,\n &quot;labels&quot;: {\n   &quot;example&quot;: &quot;true&quot;\n },\n &quot;api&quot;: {\n   &quot;targetUrl&quot;: &quot;https://httpbin.org/&quot;,\n   &quot;spec&quot;: {},\n   &quot;credentials&quot;: {\n     &quot;basic&quot;: {\n       &quot;username&quot;: &quot;{USERNAME}&quot;,\n       &quot;password&quot;: &quot;{PASSWORD}&quot;\n     }\n },\n &quot;events&quot;: {\n   &quot;spec&quot;: {\n     &quot;asyncapi&quot;: &quot;1.0.0&quot;,\n     &quot;info&quot;: {\n       &quot;title&quot;: &quot;PetStore Events&quot;,\n       &quot;version&quot;: &quot;1.0.0&quot;,\n       &quot;description&quot;: &quot;Description of all the events&quot;\n     },\n     &quot;baseTopic&quot;: &quot;stage.com.some.company.system&quot;,\n     &quot;topics&quot;: {\n       &quot;petCreated.v1&quot;: {\n         &quot;subscribe&quot;: {\n           &quot;summary&quot;: &quot;Event containing information about new pet added to the Pet Store.&quot;,\n           &quot;payload&quot;: {\n             &quot;type&quot;: &quot;object&quot;,\n             &quot;properties&quot;: {\n               &quot;pet&quot;: {\n                 &quot;type&quot;: &quot;object&quot;,\n                 &quot;required&quot;: [\n                   &quot;id&quot;,\n                   &quot;name&quot;\n                 ],\n                 &quot;example&quot;: {\n                   &quot;id&quot;: &quot;4caad296-e0c5-491e-98ac-0ed118f9474e&quot;,\n                   &quot;category&quot;: &quot;mammal&quot;,\n                   &quot;name&quot;: &quot;doggie&quot;\n                 },\n                 &quot;properties&quot;: {\n                   &quot;id&quot;: {\n                     &quot;title&quot;: &quot;Id&quot;,\n                     &quot;description&quot;: &quot;Resource identifier&quot;,\n                     &quot;type&quot;: &quot;string&quot;\n                   },\n                   &quot;name&quot;: {\n                     &quot;title&quot;: &quot;Name&quot;,\n                     &quot;description&quot;: &quot;Pet name&quot;,\n                     &quot;type&quot;: &quot;string&quot;\n                   },\n                   &quot;category&quot;: {\n                     &quot;title&quot;: &quot;Category&quot;,\n                     &quot;description&quot;: &quot;Animal category&quot;,\n                     &quot;type&quot;: &quot;string&quot;\n                   }\n                 }\n               }\n             }\n           }\n         }\n       }\n     }\n   }\n },\n &quot;documentation&quot;: {\n   &quot;displayName&quot;: &quot;Documentation&quot;,\n   &quot;description&quot;: &quot;Description&quot;,\n   &quot;type&quot;: &quot;some type&quot;,\n   &quot;tags&quot;: [&quot;tag1&quot;, &quot;tag2&quot;],\n   &quot;docs&quot;: [\n       {\n       &quot;title&quot;: &quot;Documentation title...&quot;,\n       &quot;type&quot;: &quot;type&quot;,\n       &quot;source&quot;: &quot;source&quot;\n       }\n   ]\n }\n}\n</code></pre></li>\n<li><p>Include the request body you prepared in the following call to register a service:</p>\n<ul>\n<li><p>For a cluster deployment:</p>\n<pre><code>curl -X POST -d &#39;{YOUR_REQUEST_BODY}&#39; https://gateway.{CLUSTER_DOMAIN}/{RE_NAME}/v1/metadata/services --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n</code></pre></li>\n<li><p>For a local deployment:</p>\n<pre><code>curl -X POST -d &#39;{YOUR_REQUEST_BODY}&#39; https://gateway.kyma.local:$NODE_PORT/{RE_NAME}/v1/metadata/services --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<p>A successful response returns the ID of the registered service:</p>\n<pre><code>{&quot;id&quot;:&quot;{YOUR_SERVICE_ID}&quot;}\n</code></pre><h3 id=\"check-the-details-of-a-registered-service\">Check the details of a registered service</h3>\n<ul>\n<li><p>For a cluster deployment:</p>\n<pre><code>curl https://gateway.{CLUSTER_DOMAIN}/{RE_NAME}/v1/metadata/services/{YOUR_SERVICE_ID} --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n</code></pre></li>\n<li><p>For a local deployment:</p>\n<pre><code>curl https://gateway.kyma.local:{NODE_PORT}/{RE_NAME}/v1/metadata/services/{YOUR_SERVICE_ID} --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n</code></pre></li>\n</ul>\n"
    },
    {
      "order": "08-04-register-secured-api",
      "title": "Register a secured API",
      "type": "Tutorials",
      "source": "<p>The Application Registry allows you to register a secured API for every service. The supported authentication methods are <a href=\"https://tools.ietf.org/html/rfc7617\" target=\"_blank\">Basic Authentication</a>, <a href=\"https://tools.ietf.org/html/rfc6750\" target=\"_blank\">OAuth</a>, and client certificates.</p>\n<p>You can specify only one authentication method for every secured API you register. If you try to register and specify more than one authentication method, the Application Registry returns a <code>400</code> code response.</p>\n<blockquote>\n<p><strong>NOTE:</strong> Registering a secured API is a part of registering services of an external solution connected to Kyma. To learn more about this process, follow <a href=\"#tutorials-register-a-service\">this</a> tutorial.</p>\n</blockquote>\n<h2 id=\"register-a-basic-authentication-secured-api\">Register a Basic Authentication-secured API</h2>\n<p>To register an API secured with Basic Authentication, add a <code>credentials.basic</code> object to the <code>api</code> section of the service registration request body. You must include these fields:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>username</strong></td>\n<td style=\"text-align:left\">Basic Authorization username</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>password</strong></td>\n<td style=\"text-align:left\">Basic Authorization password</td>\n</tr>\n</tbody>\n</table>\n<p>This is an example of the <code>api</code> section of the request body for an API secured with Basic Authentication:</p>\n<pre><code>    &quot;api&quot;: {\n        &quot;targetUrl&quot;: &quot;https://sampleapi.targeturl/v1&quot;,\n        &quot;credentials&quot;: {\n            &quot;basic&quot;: {\n                &quot;username&quot;: &quot;{USERNAME}&quot;,\n                &quot;password&quot;: &quot;{PASSWORD}&quot;\n            },\n        }  \n</code></pre><h2 id=\"register-an-oauth-secured-api\">Register an OAuth-secured API</h2>\n<p>To register an API secured with OAuth, add a <code>credentials.oauth</code> object to the <code>api</code> section of the service registration request body. You must include these fields:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>url</strong></td>\n<td style=\"text-align:left\">OAuth token exchange endpoint of the service</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>clientId</strong></td>\n<td style=\"text-align:left\">OAuth client ID</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>clientSecret</strong></td>\n<td style=\"text-align:left\">OAuth client Secret</td>\n</tr>\n</tbody>\n</table>\n<p>This is an example of the <code>api</code> section of the request body for an API secured with OAuth:</p>\n<pre><code>    &quot;api&quot;: {\n        &quot;targetUrl&quot;: &quot;https://sampleapi.targeturl/v1&quot;,\n        &quot;credentials&quot;: {\n            &quot;oauth&quot;: {\n                &quot;url&quot;: &quot;https://sampleapi.targeturl/authorizationserver/oauth/token&quot;,\n                &quot;clientId&quot;: &quot;{CLIENT_ID}&quot;,\n                &quot;clientSecret&quot;: &quot;{CLIENT_SECRET}&quot;\n            },\n        }  \n</code></pre><h2 id=\"register-a-client-certificate-secured-api\">Register a client certificate-secured API</h2>\n<p>To register an API and secure it with client certificates, you must add the <code>credentials.certificateGen</code> object to the <code>api</code> section of the service registration request body. The Application Registry generates a ready to use certificate and key pair for every API registered this way. You can use the generated pair or replace it with your own certificate and key.</p>\n<p>Include this field in the service registration request body:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>commonName</strong></td>\n<td style=\"text-align:left\">Name of the generated certificate. Set as the <code>CN</code> field of the certificate Subject.</td>\n</tr>\n</tbody>\n</table>\n<p>This is an example of the <code>api</code> section of the request body for an API secured with generated client certificates:</p>\n<pre><code>    &quot;api&quot;: {\n        &quot;targetUrl&quot;: &quot;https://sampleapi.targeturl/v1&quot;,\n        &quot;credentials&quot;: {\n            &quot;certificateGen&quot;: {\n                &quot;commonName&quot;: &quot;{CERT_NAME}&quot;\n            },\n        }  \n</code></pre><blockquote>\n<p><strong>NOTE:</strong> If you update the registered API and change the <code>certificateGen.commonName</code>, the Application Registry generates a new certificate-key pair for that API. When you delete an API secured with generated client certificates, the Application Registry deletes the corresponding certificate and key.</p>\n</blockquote>\n<h3 id=\"details\">Details</h3>\n<p>When you register an API with the <code>credentials.certificateGen</code> object, the Application Registry generates a SHA256withRSA-encrypted certificate and a matching key. To enable communication between Kyma and an API secured with this authentication method, set the certificate as a valid authentication medium for all calls coming from Kyma in your external solution.</p>\n<p>The certificate and key pair is stored in a Secret in the <code>kyma-integration</code> Namespace. List all Secrets and find the one created for your API:</p>\n<pre><code>kubectl -n kyma-integration get secrets\n</code></pre><p>To fetch the certificate and key encoded with base64, run this command:</p>\n<pre><code>kubectl -n kyma-integration get secrets app-{APP_NAME}-{SERVICE_ID} -o yaml\n</code></pre><blockquote>\n<p><strong>NOTE:</strong> Replace the <code>APP_NAME</code> placeholder with the name of the Application used to connect the external solution that is the origin of the API. Replace the <code>SERVICE_ID</code> placeholder with the ID of the registered service to which the API belongs. You get this ID after you register an external solution&#39;s service in Kyma.</p>\n</blockquote>\n<p>If the API you registered provides a certificate-key pair or the generated certificate doesn&#39;t meet your security standards or specific needs, you can use a custom certificate-key pair for authentication. To replace the Kyma-generated pair with your certificate and key, run this command:</p>\n<pre><code>kubectl -n kyma-integration patch secrets app-{APP_NAME}-{SERVICE_ID} --patch &#39;data:\n  crt: {BASE64_ENCODED_CRT}\n  key: {BASE64_ENCODED_KEY}&#39;\n</code></pre>"
    },
    {
      "order": "08-05-trigger-lambda-with-event",
      "title": "Trigger a lambda with events",
      "type": "Tutorials",
      "source": "<p>This guide shows how to create a simple lambda function and trigger it with an event.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ul>\n<li>An Application (App) bound to the <code>production</code> Namespace</li>\n<li>Client certificates generated for the connected App.</li>\n</ul>\n<h2 id=\"steps\">Steps</h2>\n<ol>\n<li>Register a service with the following specification to the desired App.</li>\n</ol>\n<blockquote>\n<p><strong>NOTE:</strong> See <a href=\"#getting-started-get-the-client-certificate\">this</a> Getting Started Guide to learn how to register a service.</p>\n<pre><code class=\"lang-json\">{\n  &quot;name&quot;: &quot;my-service&quot;,\n  &quot;provider&quot;: &quot;myCompany&quot;,\n  &quot;Identifier&quot;: &quot;identifier&quot;,\n  &quot;description&quot;: &quot;This is some service&quot;,\n  &quot;events&quot;: {\n    &quot;spec&quot;: {\n      &quot;asyncapi&quot;: &quot;1.0.0&quot;,\n      &quot;info&quot;: {\n        &quot;title&quot;: &quot;Example Events&quot;,\n        &quot;version&quot;: &quot;1.0.0&quot;,\n        &quot;description&quot;: &quot;Description of all the example events&quot;\n      },\n      &quot;baseTopic&quot;: &quot;example.events.com&quot;,\n      &quot;topics&quot;: {\n        &quot;exampleEvent.v1&quot;: {\n          &quot;subscribe&quot;: {\n            &quot;summary&quot;: &quot;Example event&quot;,\n            &quot;payload&quot;: {\n              &quot;type&quot;: &quot;object&quot;,\n              &quot;properties&quot;: {\n                &quot;myObject&quot;: {\n                  &quot;type&quot;: &quot;object&quot;,\n                  &quot;required&quot;: [\n                    &quot;id&quot;\n                  ],\n                  &quot;example&quot;: {\n                    &quot;id&quot;: &quot;4caad296-e0c5-491e-98ac-0ed118f9474e&quot;\n                  },\n                  &quot;properties&quot;: {\n                    &quot;id&quot;: {\n                      &quot;title&quot;: &quot;Id&quot;,\n                      &quot;description&quot;: &quot;Resource identifier&quot;,\n                      &quot;type&quot;: &quot;string&quot;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n</blockquote>\n<ol start=\"2\">\n<li><p>Get the <code>externalName</code> of the Service Class of the registered service.</p>\n<pre><code>kubectl -n production get serviceclass {SERVICE_ID}  -o jsonpath=&#39;{.spec.externalName}&#39;\n</code></pre></li>\n<li><p>Create a Service Instance for the registered service.</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceInstance\nmetadata:\nname: my-service-instance-name\nnamespace: production\nspec:\nserviceClassExternalName: {EXTERNAL_NAME}\nEOF\n</code></pre></li>\n<li><p>Create a sample lambda function which sends a request to <code>http://httpbin.org/uuid</code>. A successful response logs a <code>Response acquired successfully! Uuid: {RECEIVED_UUID}</code> message. To create and register the lambda function in the <code>production</code> Namespace, run:</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: kubeless.io/v1beta1\nkind: Function\nmetadata:\nname: my-lambda\nnamespace: production\nspec:\ndeployment:\n spec:\n   template:\n     spec:\n       containers:\n       - name: &quot;&quot;\n         resources: {}\ndeps: |-\n {\n     &quot;name&quot;: &quot;example-1&quot;,\n     &quot;version&quot;: &quot;0.0.1&quot;,\n     &quot;dependencies&quot;: {\n       &quot;request&quot;: &quot;^2.85.0&quot;\n     }\n }\nfunction: |-\n const request = require(&#39;request&#39;);\n\n module.exports = { main: function (event, context) {\n     return new Promise((resolve, reject) =&gt; {\n         const url = `http://httpbin.org/uuid`;\n         const options = {\n             url: url,\n         };\n\n         sendReq(url, resolve, reject)\n     })\n } }\n\n function sendReq(url, resolve, reject) {\n     request.get(url, { json: true }, (error, response, body) =&gt; {\n         if(error){\n             resolve(error);\n         }\n         console.log(&quot;Response acquired successfully! Uuid: &quot; + response.body.uuid);\n         resolve(response);\n     })\n }\nfunction-content-type: text\nhandler: handler.main\nhorizontalPodAutoscaler:\n spec:\n   maxReplicas: 0\nruntime: nodejs8\nservice:\n ports:\n - name: http-function-port\n   port: 8080\n   protocol: TCP\n   targetPort: 8080\n selector:\n   created-by: kubeless\n   function: my-lambda\ntimeout: &quot;&quot;\ntopic: exampleEvent\nEOF\n</code></pre></li>\n<li><p>Create a Subscription to allow events to trigger the lambda function.</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: eventing.kyma.cx/v1alpha1\nkind: Subscription\nmetadata:\nlabels:\n Function: my-lambda\nname: lambda-my-lambda-exampleevent-v1\nnamespace: production\nspec:\nendpoint: http://my-lambda.production:8080/\nevent_type: exampleEvent\nevent_type_version: v1\ninclude_subscription_name_header: true\nmax_inflight: 400\npush_request_timeout_ms: 2000\nsource_id: {APP_NAME}\nEOF\n</code></pre></li>\n<li><p>Send an event to trigger the created lambda.</p>\n<ul>\n<li>On a cluster:<pre><code>curl -X POST https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/events -k --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -d     &#39;{\n   &quot;event-type&quot;: &quot;exampleEvent&quot;,\n   &quot;event-type-version&quot;: &quot;v1&quot;,\n   &quot;event-id&quot;: &quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;,\n   &quot;event-time&quot;: &quot;2018-10-16T15:00:00Z&quot;,\n   &quot;data&quot;: &quot;some data&quot;\n}&#39;\n</code></pre></li>\n<li>On a local deployment:<pre><code>curl -X POST https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/events -k --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -d     &#39;{\n   &quot;event-type&quot;: &quot;exampleEvent&quot;,\n   &quot;event-type-version&quot;: &quot;v1&quot;,\n   &quot;event-id&quot;: &quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;,\n   &quot;event-time&quot;: &quot;2018-10-16T15:00:00Z&quot;,\n   &quot;data&quot;: &quot;some data&quot;\n}&#39;\n</code></pre></li>\n</ul>\n</li>\n<li><p>Check the logs of the lambda function to see if it was triggered. Every time an event successfully triggers the function, this message appears in the logs: <code>Response acquired successfully! Uuid: {RECEIVED_UUID}</code>. Run this command:</p>\n<pre><code>kubectl -n production logs &quot;$(kubectl -n production get po -l function=my-lambda -o jsonpath=&#39;{.items[0].metadata.name}&#39;)&quot; -c my-lambda | grep &quot;Response acquired successfully! Uuid: &quot;\n</code></pre></li>\n</ol>\n"
    },
    {
      "order": "08-06-call-registered-service-from-kyma",
      "title": "Call a registered external service from Kyma",
      "type": "Tutorials",
      "source": "<p>This guide shows how to call a registered external service from Kyma using a simple lambda function.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ul>\n<li>An Application (App) bound to the <code>production</code> Namespace</li>\n<li>Client certificates generated for the connected App.</li>\n<li>Map <code>my-lambda-production.kyma.local</code> to your Minikube IP to call the lambda function on a local Kyma deployment.</li>\n</ul>\n<h2 id=\"steps\">Steps</h2>\n<ol>\n<li><p>Register a service with the following specification to the desired Application.</p>\n<blockquote>\n<p><strong>NOTE:</strong> See <a href=\"#getting-started-register-a-service\">this</a> Getting Started Guide to learn how to register a service.</p>\n<pre><code class=\"lang-json\">{\n&quot;name&quot;: &quot;my-service&quot;,\n&quot;provider&quot;: &quot;myCompany&quot;,\n&quot;Identifier&quot;: &quot;identifier&quot;,\n&quot;description&quot;: &quot;This is some service&quot;,\n&quot;api&quot;: {\n &quot;targetUrl&quot;: &quot;http://httpbin.org/&quot;,\n &quot;spec&quot;: {\n   &quot;swagger&quot;:&quot;2.0&quot;\n }\n}\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>Get the <code>externalName</code> of the Service Class of the registered service.</p>\n<pre><code>kubectl -n production get serviceclass {SERVICE_ID}  -o jsonpath=&#39;{.spec.externalName}&#39;\n</code></pre></li>\n<li><p>Create a Service Instance for the registered service.</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceInstance\nmetadata:\nname: my-service-instance-name\nnamespace: production\nspec:\nserviceClassExternalName: {EXTERNAL_NAME}\nEOF\n</code></pre></li>\n<li><p>Create a lambda function that sends a request to the registered service with an additional path of <code>/uuid</code>. A successful response returns a UUID generated by <code>httpbin.org</code>. To create and register the lambda function in the <code>production</code> Namespace, run:</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: kubeless.io/v1beta1\nkind: Function\nmetadata:\nname: my-lambda\nnamespace: production\nspec:\ndeployment:\n spec:\n   template:\n     metadata:\n       labels:\n         re-{APP_NAME}-{SERVICE_ID}: &quot;true&quot;\n     spec:\n       containers:\n       - env:\n         - name: GATEWAY_URL\n           value: re-{APP_NAME}-{SERVICE_ID}.kyma-integration\ndeps: |-\n {\n     &quot;name&quot;: &quot;example-1&quot;,\n     &quot;version&quot;: &quot;0.0.1&quot;,\n     &quot;dependencies&quot;: {\n       &quot;request&quot;: &quot;^2.85.0&quot;\n     }\n }\nfunction: |-\n const request = require(&#39;request&#39;);\n\n module.exports = { main: function (event, context) {\n     return new Promise((resolve, reject) =&gt; {\n         const url = `http://${process.env.GATEWAY_URL}/uuid`;\n         const options = {\n             url: url,\n         };\n\n         sendReq(url, resolve, reject)\n     })\n } }\n\n function sendReq(url, resolve, reject) {\n     request.get(url, { json: true }, (error, response, body) =&gt; {\n         if(error){\n             resolve(error);\n         }\n         resolve(response.body);\n     })\n }\nfunction-content-type: text\nhandler: handler.main\nhorizontalPodAutoscaler:\n spec:\n   maxReplicas: 0\nruntime: nodejs8\nservice:\n ports:\n - name: http-function-port\n   port: 8080\n   protocol: TCP\n   targetPort: 8080\n selector:\n   created-by: kubeless\n   function: my-lambda\ntimeout: &quot;&quot;\ntopic: http\nEOF\n</code></pre></li>\n<li><p>Create a ServiceBinding and a ServiceBindingUsage to bind the Service Instance to the lambda function.</p>\n</li>\n</ol>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceBinding\nmetadata:\n  labels:\n    Function: my-lambda\n  name: my-service-binding\n  namespace: production\nspec:\n  instanceRef:\n    name: my-service-instance-name\nEOF\n</code></pre><pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: servicecatalog.kyma-project.io/v1alpha1\nkind: ServiceBindingUsage\nmetadata:\n  labels:\n    Function: my-lambda\n    ServiceBinding: my-service-binding\n  name: my-service-binding\n  namespace: production\nspec:\n  serviceBindingRef:\n    name: my-service-binding\n  usedBy:\n    kind: function\n    name: my-lambda\nEOF\n</code></pre><ol start=\"6\">\n<li><p>To expose the lambda function outside the cluster create an Api custom resource:</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: gateway.kyma-project.io/v1alpha2\nkind: Api\nmetadata:\nlabels:\n function: my-lambda\nname: my-lambda\nnamespace: production\nspec:\nauthentication: []\nhostname: my-lambda-production.{CLUSTER_DOMAIN}\nservice:\n name: my-lambda\n port: 8080\nEOF\n</code></pre></li>\n<li><p>To verify that everything was setup correctly you can now call the lambda through https:</p>\n<ul>\n<li>On a cluster<pre><code>curl https://my-lambda-production.{CLUSTER_DOMAIN}/ -k\n</code></pre></li>\n<li>On a local deployment:<pre><code>curl https://my-lambda-production.kyma.local/ -k\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<p>A successful response returns a UUID generated by <code>httpbin.org</code>:</p>\n<pre><code class=\"lang-json\">{\n  &quot;uuid&quot;: &quot;d44cc373-b26e-4a36-9890-6418d131a285&quot;\n}\n</code></pre>\n"
    },
    {
      "order": "08-07-application-mapping",
      "title": "Bind an Application to a Namespace",
      "type": "Tutorials",
      "source": "<p>This guide shows you how to bind an Application (App) to a Namespace in Kyma. To execute the binding, create an ApplicationMapping custom resource in the cluster. Follow the instructions to bind your App to the <code>production</code> Namespace.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>To complete this guide, your cluster must have at least one App created.</p>\n<h2 id=\"steps\">Steps</h2>\n<ol>\n<li><p>List all Apps bound to the <code>production</code> Namespace:</p>\n<pre><code>kubectl get em -n production\n</code></pre></li>\n<li><p>Bind an App to a Namespace. Run this command to create an ApplicationMapping custom resource and apply it to the cluster:</p>\n<pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: ApplicationMapping\nmetadata:\n name: {NAME_OF_APP_TO_BIND}\n namespace: production\nEOF\n</code></pre></li>\n<li><p>Check if the operation is successful. List all Namespaces to which your App is bound:</p>\n<pre><code>kubectl get em --all-namespaces -o jsonpath=&#39;{range .items[?(@.metadata.name==&quot;{NAME_OF_YOUR_APP}&quot;)]}{@.metadata.namespace}{&quot;&quot;}{end}&#39;\n</code></pre></li>\n</ol>\n"
    },
    {
      "order": "09-01-connector-service",
      "title": "Connector Service",
      "type": "API",
      "source": "<p>The Connector Service exposes two separate APIs:</p>\n<ul>\n<li>An internal API available in the Kyma cluster used to initiate certificate generation.</li>\n<li>An external API exposed through Ingress used to finalize certificate generation.</li>\n</ul>\n<p>Find the specification of both of these APIs <a href=\"./assets/connectorapi.yaml\">here</a>.</p>\n<p>Alternatively, get the API specification directly from the Connector Service:</p>\n<pre><code>https://connector-service.{CLUSTER_DOMAIN}/v1/api.yaml\n</code></pre><p>Run this command to access the API specification on a local Kyma deployment:</p>\n<pre><code>curl https://connector-service.kyma.local/v1/api.yaml\n</code></pre>"
    },
    {
      "order": "09-02-metadata-service",
      "title": "Application Registry",
      "type": "API",
      "source": "<p>You can get the API specification of the Application Registry for a given version of the service using this command:</p>\n<pre><code>curl https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/api.yaml\n</code></pre><p>To access the API specification of the Application Registry locally, provide the NodePort of the <code>application-connector-nginx-ingress-controller</code>.</p>\n<p>To get the NodePort, run this command:</p>\n<pre><code>kubectl -n kyma-system get svc application-connector-nginx-ingress-controller -o &#39;jsonpath={.spec.ports[?(@.port==443)].nodePort}&#39;\n</code></pre><p>To access the specification, run:</p>\n<pre><code>curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/metadata/api.yaml\n</code></pre>"
    },
    {
      "order": "09-03-event-service",
      "title": "Event Service",
      "type": "API",
      "source": "<p>See <a href=\"./assets/eventsapi.yaml\">this file</a> for the Event Service API specification.</p>\n"
    }
  ]
}
