{
  "id": "tracing",
  "displayName": "Tracing",
  "description": "Overal documentation for Tracing",
  "type": "Components",
  "docs": [
    {
      "order": "001-overview-tracing",
      "title": "Overview",
      "type": "Overview",
      "source": "<p>The microservice architecture differs from the traditional monoliths in many aspects. From the request observability perspective, there are asynchronous boundaries among various different microservices that compose a request flow. Moreover, these microservices can have heterogeneous semantics when it comes to monitoring. A tracing solution that provides a holistic view of the request flow helps you to understand the system and take informed decisions regarding troubleshooting and performance optimization.</p>\n<p>Tracing in Kyma uses <a href=\"https://www.jaegertracing.io/docs/\" target=\"_blank\">Jaeger</a> as a back end which serves as the query mechanism for displaying information about traces.</p>\n"
    },
    {
      "order": "010-architecture-tracing",
      "title": "Architecture",
      "source": "<p>The diagram presents the tracing flow including the details of requesting and storing traces. </p>\n<p><img src=\"./assets/tracing-architecture.svg\" alt=\"Tracing architecture\"></p>\n<p>The Jaeger Deployment is the central element of the tracing architecture.\nIt serves as a target of all query requests sent from the Jaeger UI. It is also the space for storing and processing the spans and traces created by Envoy, Istio, and Kyma services. </p>\n<h2 id=\"request-traces\">Request traces</h2>\n<p>The process of requesting traces from Jaeger looks as follows: </p>\n<ol>\n<li>A Kyma user accesses Jaeger UI.</li>\n<li>The user uses the UI to request the trace details for a given service by selecting the service from the <strong>Services</strong> drop-down menu and confirming the choice by selecting the <strong>Find Traces</strong> button. Jaeger passes the request to jaeger-query, which is the UI facade.</li>\n<li>The jaeger-query forwards the details to Jaeger Deployment. The kcproxy verifies each request and if the authentication is successful, Jaeger sends the requested information back.</li>\n</ol>\n<p><img src=\"./assets/request-traces.svg\" alt=\"Request traces\"></p>\n<h2 id=\"store-traces\">Store traces</h2>\n<p>Traces are stored in Jaeger in the following way:</p>\n<ol>\n<li>A Kyma user configures the application to propagate the correct <a href=\"https://istio.io/docs/tasks/telemetry/distributed-tracing.html#understanding-what-happened\" target=\"_blank\">HTTP headers</a> for the outbound calls.</li>\n<li>Envoy passes the trace details to the Zipkin Kubernetes service. This service acts as a facade receiving the trace and span details.</li>\n<li>The Zipkin service forwards the tracing information to Jaeger Deployment, allowing it to process them. </li>\n</ol>\n<p><img src=\"./assets/store-traces.svg\" alt=\"Store traces\"></p>\n"
    },
    {
      "order": "020-details-jaeger",
      "title": "Jaeger",
      "type": "Details",
      "source": "<h2 id=\"overview\">Overview</h2>\n<p><a href=\"http://jaeger.readthedocs.io/en/latest/\" target=\"_blank\">Jaeger</a> is a monitoring and tracing tool for microservice-based distributed systems. Its features include the following:</p>\n<ul>\n<li>Distributed context propagation</li>\n<li>Distributed transaction monitoring</li>\n<li>Root cause analysis</li>\n<li>Service dependency analysis</li>\n<li>Performance and latency optimization</li>\n</ul>\n<h2 id=\"usage\">Usage</h2>\n<p>The Envoy sidecar uses Jaeger to trace the request flow in the Istio Service Mesh. Jaeger is compatible with the Zipkin protocol, which Istio and Envoy use to communicate with the tracing back end. This allows you to use the Zipkin protocol and clients in Istio, Envoy, and the Kyma services.</p>\n<p>For details, see <a href=\"https://istio.io/docs/tasks/telemetry/distributed-tracing.html\" target=\"_blank\">Istio&#39;s Distributed Tracing</a>.</p>\n<h2 id=\"install-jaeger-locally\">Install Jaeger locally</h2>\n<p>While Jager installs automatically during cluster installation, local Jaeger installation is optional. You can install Jaeger on a Kyma instance and run it locally using Helm.</p>\n<p>To install Jaeger locally, go to the <code>~/go/src/github.com/kyma-project/kyma/resources/</code> directory and run the following command:</p>\n<pre><code class=\"lang-bash\">$ helm install -n jaeger -f jaeger/values.yaml --namespace kyma-system --set-string global.domainName=kyma.local --set-string global.isLocalEnv=true jaeger/\n</code></pre>\n<h2 id=\"access-jaeger\">Access Jaeger</h2>\n<p>Access the Jaeger UI either locally at <code>https://jaeger.kyma.local</code> or on a cluster at <code>https://jaeger.{domain-of-kyma-cluster}</code>. </p>\n"
    },
    {
      "order": "021-details-http-headers",
      "title": "Propagate HTTP headers",
      "type": "Details",
      "source": "<p>The Envoy proxy controls the inbound and outbound traffic in the application and automatically sends the trace information to Zipkin. To track the flow of the REST API calls or the service injections in Kyma, it requires the application to cooperate with the microservices code. To enable such cooperation, configure the application to propagate the tracing context in HTTP headers when making outbound calls. See the <a href=\"https://istio.io/docs/tasks/telemetry/distributed-tracing.html#understanding-what-happened\" target=\"_blank\">Istio documentation</a> for details on headers required to ensure the correct tracing in Kyma.</p>\n"
    },
    {
      "order": "022-details-trace-comparison",
      "title": "Compare traces",
      "type": "Details",
      "source": "<p>Trace comparison allows you to compare the structure of two traces, rendered as a tree of connected services and operations. The colors help you to distinguish the differences between two traces.</p>\n<p>Compare the traces using the <strong>Jaeger</strong> user interface.</p>\n<ol>\n<li><p>In the search page for traces, select the traces to compare and click <strong>Compare Traces</strong>.</p>\n<p><img src=\"./assets/list-traces.png\" alt=\"Tracing architecture\"></p>\n</li>\n<li><p>The page shows the comparison of two traces selected in the previous step. The traces are marked with <strong>A</strong> and <strong>B</strong>.</p>\n<p><img src=\"./assets/compare-traces-1.png\" alt=\"Tracing architecture\"></p>\n</li>\n<li><p>Use the top menus for <strong>A</strong> and <strong>B</strong> to select the traces you want to compare.</p>\n<p><img src=\"./assets/compare-traces-2.png\" alt=\"Tracing architecture\"></p>\n<p>Trace spans have different colors which indicate their meaning:</p>\n<ul>\n<li>Dark colors indicate that the span is missing from one of the traces:<ul>\n<li>Dark red: The span is only present in trace <strong>A</strong>.</li>\n<li>Dark green: The span is only present in trace <strong>B</strong>.</li>\n</ul>\n</li>\n<li>Light colors indicate that the span is present in both traces but occurs more often in one of the traces:<ul>\n<li>Light red: The span in <strong>A</strong> has more spans than <strong>B</strong>.</li>\n<li>Light green: The span in B has more spans than <strong>A</strong>.</li>\n</ul>\n</li>\n<li>Gray: indicates that two traces have a span and the same number of further spans grouped in it.</li>\n</ul>\n<p>Additionally, spans are marked with numerical values indicating how often they occur in compared traces. The values can be positive or negative.</p>\n<blockquote>\n<p><strong>NOTE:</strong> Missing spans can be interpreted as either the application not calling the downstream service, which might be a bug, or that the downstream service is down.</p>\n</blockquote>\n<p><img src=\"./assets/compare-traces-colors.png\" alt=\"Tracing architecture\"></p>\n</li>\n</ol>\n"
    },
    {
      "order": "023-details-distributed-tracing",
      "title": "Benefits of distributed tracing",
      "type": "Details",
      "source": "<p>Observability tools should clearly show the big picture, no matter if they help you monitor just a couple or multiple components. In a cloud-native microservice architecture, a user request often flows through dozens of different microservices. Tools such as logging or monitoring help to track the way, however, they treat each component or microservice in isolation. This individual treatment results in operational issues. </p>\n<p>Distributed tracing charts out the transactions in cloud-native systems, helping you to understand the application behavior and relations between the front end actions and back end implementation. </p>\n<p>The diagram shows how the distributed tracing helps to track the request path.</p>\n<p><img src=\"./assets/distributed-tracing.svg\" alt=\"Distributed tracing\"></p>\n"
    }
  ]
}
